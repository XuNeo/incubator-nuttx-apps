/****************************************************************************
 * apps/examples/luavgldemo/luavgldemo.c
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.  The
 * ASF licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 ****************************************************************************/

/****************************************************************************
 * Included Files
 ****************************************************************************/

#include <nuttx/config.h>

#include <sys/boardctl.h>
#include <sys/param.h>
#include <unistd.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <debug.h>

#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#include <luavgl.h>

#include <lvgl/lvgl.h>
#include <port/lv_port.h>

#ifdef CONFIG_LIBUV
#  include <uv.h>
#  include <port/lv_port_libuv.h>
#endif

/****************************************************************************
 * Pre-processor Definitions
 ****************************************************************************/

/* Should we perform board-specific driver initialization?  There are two
 * ways that board initialization can occur:  1) automatically via
 * board_late_initialize() during bootupif CONFIG_BOARD_LATE_INITIALIZE
 * or 2).
 * via a call to boardctl() if the interface is enabled
 * (CONFIG_BOARDCTL=y).
 * If this task is running as an NSH built-in application, then that
 * initialization has probably already been performed otherwise we do it
 * here.
 */

#undef NEED_BOARDINIT

#if defined(CONFIG_BOARDCTL) && !defined(CONFIG_NSH_ARCHINIT)
#  define NEED_BOARDINIT 1
#endif

#define LUAVGL_EXAMPLE_DIR "/data/../apps/interpreters/luamodules/luavgl/luavgl/examples"
/****************************************************************************
 * Private Type Declarations
 ****************************************************************************/

typedef struct {
  lua_State *L;
  lv_obj_t *root;
} lua_context_t;

typedef struct {
  lv_obj_t *root;
  make_font_cb make_font;
  delete_font_cb delete_font;
} luavgl_args_t;

/****************************************************************************
 * Private Data
 ****************************************************************************/

/****************************************************************************
 * Private Functions
 ****************************************************************************/

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message(const char *pname, const char *msg)
{
  printf("%s: %s\n", pname ? pname : " ", msg);
}

/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report(lua_State *L, int status)
{
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    l_message("luactx", msg);
    lua_pop(L, 1); /* remove message */
  }
  return status;
}

/*
** Message handler used to run all chunks
*/
static int msghandler(lua_State *L)
{
  const char *msg = lua_tostring(L, 1);
  if (msg == NULL) {                         /* is error object not a string? */
    if (luaL_callmeta(L, 1, "__tostring") && /* does it have a metamethod */
        lua_type(L, -1) == LUA_TSTRING)      /* that produces a string? */
      return 1;                              /* that is the message */
    else
      msg = lua_pushfstring(L, "(error object is a %s value)",
                            luaL_typename(L, 1));
  }

  /* append a standard traceback */
  luaL_traceback(L, L, msg, 1);

  msg = lua_tostring(L, -1);
  lua_pop(L, 1);

  lv_obj_t *root = NULL;
  luavgl_ctx_t *ctx = luavgl_context(L);
  root = ctx->root ? ctx->root : lv_scr_act();
  lv_obj_t *label = lv_label_create(root);
  lv_label_set_text(label, msg);
  lv_label_set_long_mode(label, LV_LABEL_LONG_WRAP);
  lv_obj_set_style_text_font(label, LV_FONT_DEFAULT, 0);
  lv_obj_set_width(label, LV_PCT(80));
  lv_obj_center(label);

  printf("trace back: \n%s\n", msg);
  return 0; /* return no trace, since we already processed it. */
}

static int lua_panic(lua_State *L)
{
  printf("LUA panic:\n%s\n", lua_tostring(L, -1));
  return 0; /* return to Lua to abort */
}

/*
** protected main entry
*/
static int pmain(lua_State *L)
{
  int status;
  const char *script = lua_tostring(L, 1);

  luavgl_args_t *args = lua_touserdata(L, 2);
  if (args == NULL || args->root == NULL) {
    printf("Null root object.\n");
    return 0;
  }

  luavgl_set_root(L, args->root);
  luavgl_set_font_extension(L, args->make_font, args->delete_font);

  /**
   * Set global variable SCRIPT_PATH, to make image src path easier.
   */
  char *path = strdup(script);
  if (path == NULL) {
    printf("no memory.\n");
    return 0;
  }

  int i = strlen(path);
  for (; i; i--) {
    if (path[i] == '/') {
      path[i + 1] = '\0';
      break;
    }
  }

  printf("script path: %s\n", path);
  lua_pushstring(L, path);
  lua_setglobal(L, "SCRIPT_PATH");
  luaL_openlibs(L);

  lua_getglobal(L, "package");
  lua_getfield(L, -1, "path");

  const char *pkg_path = lua_tostring(L, -1);
  char *new_path = malloc(strlen(pkg_path) + strlen(script) + 2);
  strcpy(new_path, pkg_path);
  strcat(new_path, ";"), strcat(new_path, path), strcat(new_path, "?.lua");
  lua_pop(L, 1);
  lua_pushstring(L, new_path);
  lua_setfield(L, -2, "path");
  lua_pop(L, 1);
  free(path);
  free(new_path);

  lua_atpanic(L, &lua_panic);

  lua_pushcfunction(L, msghandler); /* push message handler */
  int base = lua_gettop(L);
  status = luaL_loadfile(L, script);
  if (status != LUA_OK) {
    lua_pushfstring(L, "failed to load: %s\n", script);
    /* manually show the error to screen. */
    lua_insert(L, 1);
    msghandler(L);
    return 0;
  }

  status = lua_pcall(L, 0, 0, base);
  lua_remove(L, base); /* remove message handler from the stack */
  report(L, status);
  lua_pushboolean(L, 1); /* signal no errors */
  return 1;
}

static lua_context_t *lua_load_script(const char *script, luavgl_args_t *args)
{
  int ret, status;
  /* create the thread to run script. */
  if (script == NULL) {
    printf("args error.\n");
    return NULL;
  }

  printf("run script: %s\n", script);
  lua_State *L = luaL_newstate(); /* create state */
  if (L == NULL) {
    printf("no mem for lua state.\n");
    return NULL;
  }

  lua_pushcfunction(L, &pmain); /* to call 'pmain' in protected mode */
  lua_pushstring(L, script);
  lua_pushlightuserdata(L, args);
  status = lua_pcall(L, 2, 1, 0); /* do the call */
  ret = lua_toboolean(L, -1);
  report(L, status);
  if (!ret || status != LUA_OK) {
    /* This should never happen */
    printf("pcall failed.\n");
    lua_close(L);
    return NULL;
  }

  /* script may fail, but we continue until page destoried. */
  lua_context_t *luactx = calloc(sizeof(*luactx), 1);
  if (luactx == NULL) {
    printf("no memory.\n");
    goto lua_exit;
  }

  luactx->L = L;
  luactx->root = args->root;
  return luactx;

lua_exit:
  lua_close(L);

  return NULL;
}

static int lua_terminate(lua_context_t *luactx)
{
  lua_State *L = luactx->L;

  lua_close(L);
  free(luactx);
  return 0;
}

static lua_context_t *lua_ctx;
static luavgl_args_t args;

static void reload_cb(lv_event_t *e)
{
  (void)e;
  if (lua_ctx != NULL) {
    lua_terminate(lua_ctx);
  }

  lua_ctx = lua_load_script(LUAVGL_EXAMPLE_DIR "/examples.lua", &args);
}

/****************************************************************************
 * Public Functions
 ****************************************************************************/

/****************************************************************************
 * Name: main or lvgldemo_main
 *
 * Description:
 *
 * Input Parameters:
 *   Standard argc and argv
 *
 * Returned Value:
 *   Zero on success; a positive, non-zero value on failure.
 *
 ****************************************************************************/

int main(int argc, FAR char *argv[])
{
#ifdef CONFIG_LIBUV
  uv_loop_t ui_loop;
#endif

#ifdef NEED_BOARDINIT
  /* Perform board-specific driver initialization */

  boardctl(BOARDIOC_INIT, 0);

#ifdef CONFIG_BOARDCTL_FINALINIT
  /* Perform architecture-specific final-initialization (if configured) */

  boardctl(BOARDIOC_FINALINIT, 0);
#endif
#endif

  /* LVGL initialization */

  lv_init();

  /* LVGL port initialization */

  lv_port_init();

  /* LVGL demo creation */

  args.root = lv_scr_act();

  lua_ctx = lua_load_script(LUAVGL_EXAMPLE_DIR "/examples.lua", &args);

  lv_obj_t *btn = lv_btn_create(lv_layer_sys());
  lv_obj_align(btn, LV_ALIGN_BOTTOM_RIGHT, 0, -50);
  lv_obj_set_size(btn, LV_SIZE_CONTENT, LV_SIZE_CONTENT);
  lv_obj_set_style_pad_all(btn, 5, 0);
  lv_obj_add_event_cb(btn, reload_cb, LV_EVENT_CLICKED, NULL);
  lv_obj_t* label = lv_label_create(btn);
  lv_label_set_text(label, "RELOAD");
  lv_obj_center(label);

  /* Handle LVGL tasks */

#ifdef CONFIG_LIBUV
  uv_loop_init(&ui_loop);
  lv_port_libuv_init(&ui_loop);
  uv_run(&ui_loop, UV_RUN_DEFAULT);
#else
  while (1)
    {
      uint32_t idle;
      idle = lv_timer_handler();

      /* Minimum sleep of 1ms */

      idle = idle ? idle : 1;
      usleep(idle * 1000);
    }
#endif

  return EXIT_SUCCESS;
}
